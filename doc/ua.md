# Документація Indb.js

Ласкаво просимо до документації проекту Indb.js.

---

## `await init(database, version, tables)`

Метод `init` відкриває з'єднання з базою даних (або створює її). Приймає три обов'язкові аргументи:

- **database** — ім'я бази даних (рядок).
- **version** — номер версії (число).
- **tables** — JSON-об'єкт зі схемою таблиць.

### Приклад об'єкта таблиць

```javascript
const tables = {
    songs: { // Ім'я таблиці (ObjectStore)
        increment: "id", // Поле, яке буде автоінкрементним первинним ключем
        indexes: { // Індекси для таблиці songs
            title: {
                name: "title",
                unique: false,
                multiEntry: false
            }
        }
    }
    // ...інші таблиці
};
```

### Приклад ініціалізації

```javascript
const indb = new Indb();
await indb.init("mydb", 1, tables);
```

### Примітка

В описі індексів поле `name` можна не вказувати, якщо ім'я індексу збігається з ім'ям поля в базі. Вказуйте його лише тоді, коли хочете задати індексу ім'я, відмінне від поля таблиці.

---

## `await importData(json, overwrite = false)`

Метод `importData` дозволяє імпортувати дані з JSON-об'єкта в базу даних.

- **json** — об'єкт з даними. **Увага!** Це має бути JavaScript-об'єкт, а не JSON-рядок. Обов'язковий аргумент.
- **overwrite** — булеве значення.
    - `true`: повністю перезаписати таблицю (старі дані видаляються).
    - `false`: (за замовчуванням) додати нові дані до існуючих.

### Приклад структури даних

```javascript
const jsonData = {
    songs: [ // Масив записів для таблиці 'songs'
        {
            title: "song1",
            path: "[https://mysong.local/file1.mp3](https://mysong.local/file1.mp3)"
        },
        {
            title: "Song2",
            path: "[https://mysong.local/file2.mp3](https://mysong.local/file2.mp3)"
        }
    ]
    // ...дані для інших таблиць
};
```

### Використання

```javascript
await indb.importData(jsonData); // Додаємо нові записи до старих
await indb.importData(jsonData, true); // Очищаємо таблиці та записуємо лише нові дані
```

---

## `await exportData()`

Метод дозволяє експортувати всі дані з бази у вигляді об'єкта.

### Приклад

```javascript
const data = await indb.exportData();
console.log(data);
```

---

## `await drop(database)`

Метод видаляє зазначену базу даних з браузера.

**Увага!** Для успішного видалення необхідно закрити всі вкладки з цим сайтом, крім тієї, в якій виконується видалення. Це вимога специфікації IndexedDB (подія `onblocked`).

### Приклад

```javascript
await indb.drop("mydb"); // поверне true у разі успіху
```

---

## `await add(table, data)`

Метод додає один запис або масив записів у таблицю. Поле автоінкременту вказувати не потрібно, база призначить його сама.

### Приклад

```javascript
// Один запис
await indb.add("songs", {
    title: "song3",
    path: "[https://mysongs.local/file3.mp3](https://mysongs.local/file3.mp3)"
});

// Кілька записів
await indb.add("songs", [
    { title: "song4", path: "..." },
    { title: "song5", path: "..." }
]);
```

---

## `await put(table, data)`

Метод оновлює запис у таблиці або створює новий, якщо ключа немає. Також приймає масив об'єктів або один об'єкт.

**Важливо:** Метод повністю перезаписує об'єкт. Якщо ви передасте об'єкт не повністю (без деяких полів), старі поля будуть втрачені.

### Приклад

```javascript
await indb.put("songs", {
    id: 1, // Обов'язково вказуємо ID для оновлення
    title: "songs34",
    path: "[https://mysongs.local/file3.mp3](https://mysongs.local/file3.mp3)"
});
// З масивом об'єктів так само як в add, тільки не забуваємо вказувати id.
```

### Примітка

Якщо ви не передасте поле з первинним ключем (наприклад, `id`), метод спрацює як `add` — додасть новий запис замість оновлення старого.

---

## `await delete(table, id)`

Метод видаляє один запис з таблиці за його ключем (ID).

### Приклад

```javascript
await indb.delete("songs", 3);
```

---

## `await deleteMany(table, ids)`

Метод видаляє кілька записів за списком їхніх ID.

### Приклад

```javascript
await indb.deleteMany("songs", [1, 2, 3]);
```

---

## `await update(table, id, data)`

Метод дозволяє змінити конкретні поля в існуючому записі, не перезаписуючи об'єкт повністю.

### Приклад

```javascript
await indb.update("songs", 3, { title: "song321" });
```

---

## `await clear(table)`

Метод повністю очищає зазначену таблицю (видаляє всі записи).

### Приклад

```javascript
await indb.clear("songs");
```

---

## `await get(table, id)`

Метод отримує один запис з таблиці за його ID.

### Приклад

```javascript
let data = await indb.get("songs", 1);
console.log(data); 
// Результат: {title: "song1", path: "[https://mysongs.local/file1.mp3](https://mysongs.local/file1.mp3)", id: 1}
```

---

## `await findBy(table, index, value)`

Метод знаходить **перший** запис, що відповідає критеріям пошуку (індекс + значення).

### Приклад

```javascript
let data = await indb.findBy("songs", "title", "song1");
```

---

## `await findAll(table, index, value)`

Метод отримує масив усіх записів, що відповідають критеріям пошуку.

### Приклад

```javascript
// Поверне масив усіх пісень, де title === "song1"
let data = await indb.findAll("songs", "title", "song1"); 
```

---

## `await getAll(table)`

Метод повертає абсолютно всі записи із зазначеної таблиці.

### Приклад

```javascript
let data = await indb.getAll("songs");
```

---

## `tokens(string)`

Допоміжний метод. Перетворює рядок на масив слів (токенів). Він видаляє розділові знаки, залишаючи тільки букви та цифри. Це корисно для створення пошукових індексів з параметром `multiEntry: true`.

### Приклад

```javascript
let a = indb.tokens("hello, world!");
console.log(a); // ["hello", "world"]
```

---

## `await search(table, index, value, op = "and")`

Метод виконує повнотекстовий пошук по таблиці (використовуючи токенізацію).
Як `value` передається рядок слів.

Метод приймає необов'язковий четвертий параметр `op` (логіка пошуку):
- `"and"` (за замовчуванням): запис повинен містити **всі** слова із запиту (перетин).
- `"or"`: запис повинен містити **хоча б одне** слово із запиту (об'єднання).

### Приклад

```javascript
// Знайде записи, де є І "My", І "super", І "song"
let strictSearch = await indb.search("songs", "title", "My super song", "and"); 

// Знайде всі записи, де зустрічається будь-яке з цих слів
let broadSearch = await indb.search("songs", "title", "rock metal", "or");
```

**Примітка:** Всередині методу виконується автоматична токенізація рядка запиту. Розробнику не потрібно викликати `tokens()` вручну. Якщо вам потрібен точний збіг цілої фрази (без розбивки на слова), краще використовувати `findBy` або `findAll`.

---

## `await select(obj)`

Універсальний метод для вибірки даних з підтримкою пагінації та сортування (використовує курсори). Приймає об'єкт параметрів:

- **table** — Ім'я таблиці (обов'язково).
- **index** — Ім'я індексу (необов'язково, якщо пошук йде не за первинним ключем).
- **value** — Значення для пошуку (застосовується тільки разом з index).
- **offset** — Скільки записів пропустити (зміщення).
- **limit** — Скільки записів повернути.
- **direction** — Напрямок сортування (`next` або `prev`).

Параметр `value` може бути рядком або діапазоном (об'єктом IDBKeyRange).

**Приклад діапазонів:**
```javascript
{
    value: "hello" // Точний збіг
}
// або
{
    value: { start: 1, end: 5 } // Діапазон: наприклад, від 1 до 5 років
}
```

### Приклад запиту

```javascript
let querySelect = await indb.select({
    table: "users",
    index: "shop",      // Шукаємо за індексом магазину
    value: "Kaufland",  // Значення: Kaufland
    offset: 10,         // Пропустити перші 10 знайдених
    limit: 10,          // Повернути наступні 10
    direction: "prev"   // Сортування у зворотному порядку
});
```

---

## `await remove(obj)`

Метод масового видалення записів. Приймає такий самий об'єкт параметрів, як і `select` (дозволяє видалити діапазон даних або дані за фільтром).

---

## `await count(obj)`

Метод повертає кількість записів, що відповідають запиту. Об'єкт параметрів ідентичний методу `select`.